---
layout: post
title:  "윈도우 함수 (Window Function)"
parent: SQL
nav_order: 7
date:   2022-02-15 16:52:00 +0900
---
# Window Functions
{: .no_toc }

<details open markdown="block">
  <summary>
    목차
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

집계 함수 값 (aggregate values)을 추출할 때, 모든 non-aggregate columns (country_id, season, date)에 대해 `GROUP BY`를 적용하도록 요구됨.

```sql
SELECT
  country_id,
  season,
  date,
  AVG(home_goal) AS avg_home
FROM match
GROUP BY country_id;
-- ERROR: column "match.season" must appear in the GROUP BY clause or be used in an aggregate function
```

## Window functions
윈도우 함수는 현재 행 (Current row) 와 연관된 행 집합 (Window) 에 대해 계산을 수행한다.
- `GROUP BY` 집계 함수와 유사하지만, 윈도우 함수의 경우 **모든 행이 OUTPUT에 남아있다**.
- Aggregate calculation은 `SELECT` 문에서의 서브쿼리와 유사함.
- (`ORDER BY` 문을 제외하고) 모든 쿼리가 처리된 이후에 수행되며 쿼리 결과를 활용함
- PostgreSQL, Oracle, MySQL, SQL Server 등에서는 지원하지만, SQLite에서는 지원하지 않음

```sql
FUNCTION_NAME() OVER(...)
-- ORDER BY
-- PARTITION BY
-- ROWS/RANGE PRECEDING/FOLLOWING/UNBOUNDED
```

윈도우 함수의 활용
1. 이전 또는 이후 행들로부터 값들을 Fetch
  - 현재 챔피언이 누구인지 (Reigning champion)
  - 시간에 따른 성장 계산 (Growth over time)
2. 정렬된 리스트 내 값의 위치를 기반으로 각 행의 랭킹을 매김
3. 누계 (Running total)와 이동 평균 (Moving average) 계산

## ROW_NUMBER (Function)
---
### 메달 수상자 행마다 번호 붙이기
```sql
SELECT
  Year, Event, Country,
  ROW_NUMBER() OVER () AS Row_N
FROM Summer_Medals
WHERE
  Medal = 'Gold';
```

OUTPUT

| Year | Event | Country | Row_N | 
|------|----------------------------|---------|-------| 
|1896|100M Freestyle |HUN |1 | 
| 1896 | 100M Freestyle For Sailors | GRE | 2 |
| 1896 | 1200M Freestyle | HUN | 3 | 
|...|... |... |...| 

## ORDER BY (Over)
---
`OVER` 안에 `ORDER BY`를 적용하면, 현재 행과 연관된 행들이 정렬된다.
- 예 - `ROW_NUMBER() OVER(GROUP BY YEAR DESC)` 문은 가장 최근 연도의 행부터 역순으로 1을 부여함.

### 최근 연도 순으로 번호 붙이기
```sql
SELECT
  Year, Event, Country,
  ROW_NUMBER() OVER (ORDER BY Year DESC) AS ROW_N
FROM Summer_Medals
WHERE
  Medal = 'Gold';
```

OUTPUT

| Year | Event         | Country | Row_N |
|------|---------------|---------|-------|
| 2012 | Wg 96 KG|IRI|1|
| 2012 | 4X100M Medley|USA|2|
| 2012 | Wg 84 KG|RUS|3|
| ... | ...|...|...|
| 2008 | 50M Freestyle | BRA |637|
|2008|96-120KG |CUB |638|
| ... | ... | ...|...|

### 최근 연도-종목 이름 순으로 번호 붙이기
```sql
SELECT
  Year, Event, Country,
  ROW_NUMBER() OVER
    (ORDER BY Year DESC, Event ASC) AS Row_N
FROM Summer_Medals
WHERE
  Medal = 'Gold';
```

OUTPUT

| Year | Event | Country | Row_N | 
|------|---------|---------|-------| 
|2012|+100KG|FRA |1 | 
|2012|+67KG|SRB |2 | 
|2012|+78KG |CUB |3 | 
|... |... |... |... |

### 최근 연도-종목 이름 순으로 번호 붙이고, 국가명-순번 순으로 정렬
ORDER BY in/out OVER: `OVER` 문 안에 있는 `ORDER BY`가 적용된 다음, 밖에 있는 `ORDER BY`가 적용된다.

```sql
SELECT
  Year, Event, Country,
  ROW_NUMBER() OVER
    (ORDER BY Year DESC, Event ASC) AS Row_N
FROM Summer_Medals
WHERE
  Medal = 'Gold'
ORDER BY Country ASC, Row_N ASC;
```

OUTPUT

| Year | Event   | Country | Row_N |
|------|---------|---------|-------|
| 2012 | 1500M|ALG|36| 
| 2000 | 1500M|ALG |1998| 
| 1996 | 1500M|ALG |2662| 
| ...  | ...|... |... |

## Aggregate function (Function)
---
### 2011/12 시즌 경기별 득점과 평균 득점 비교
```sql
SELECT
    date,
    (home_goal + away_goal) AS goals,
    AVG(home_goal + away_goal) OVER() AS overall_avg
FROM match
WHERE season = '2011/2012';
```

OUTPUT

| date       | goals | overall_avg       |
|------------|-------|-------------------|
 | 2011-07-29 | 3| 2.71646           |
| 2011-07-30 | 2| 2.71646           |
| 2011-07-30 | 4| 2.71646           |
| 2011-07-30 | 1| 2.71646           |

## RANK (Function)
---
### 2011/12 시즌 경기별 득점 및 다득점 순위
```sql
SELECT
    date,
    (home_goal + away_goal) AS goals,
    RANK() OVER(ORDER BY home_goal + away_goal DESC) AS goals_rank
FROM match
WHERE season = '2011/2012';
```

OUTPUT

| date       | goals | goals_rank |
|------------|-------|------------|
 | 2011-11-06 | 10|1|
| 2011-08-28 | 10|1|
| 2012-05-12 | 9|3|
| 2012-02-12 | 9|3|


## PARTITION BY (Over)
---
컬럼 내 고유 값을 기반으로 테이블을 여러 개의 partitions으로 분리하며, 같은 컬럼 내에서도 다른 계산을 수행한다.
- 윈도우 함수에 의해 각각 처리된다
  - `ROW_NUMBER`는 각 partition마다 초기화 된다.
  - `LAG`는 이전 행이 같은 partition에 있을 때만 이전 값을 fetch한다.
- 1개 이상의 컬럼에 대하여 데이터를 partition할 수 있다.
- aggregate calculation, ranks에 대해서도 수행할 수 있다.

### Motivation
```sql
  WITH Discus_Gold AS (
  SELECT
    Year, Event, Country AS Champion
  FROM Summer_Medals
  WHERE
    Year IN (2004, 2008, 2012)
    AND Gender = 'Men' AND Medal = 'Gold'
    AND Event IN ('Discus Throw', 'Triple Jump')
    AND Gender = 'Men')
SELECT
  Year, Event, Champion,
  LAG(Champion) OVER
    (ORDER BY Event ASC, Year ASC) AS Last_Champion
FROM Discus_Gold
ORDER BY Event ASC, Year ASC;
```

OUTPUT

|Year |Event |Champion |Last_Champion |
|---|---|---|---|
| 2004 | Discus Throw | LTU| null |
| 2008 | Discus Throw | EST| LTU|
| 2012 | Discus Throw | GER| EST|
| 2004 | Triple Jump  | SWE| GER|
| 2008 | Triple Jump  | POR| SWE|
| 2012 | Triple Jump  | USA| POR|

`Event`가 `Discus Throw`에서 `Triple Jump`로 바뀌었기 떄문에 04년도 `Triple Jump`의 `Last_Champion` 컬럼은 `null`이 되어야 함!

### 종목-연도별 전년도 챔피언
```sql
WITH Discus_Gold AS (...)

SELECT
  Year, Event, Champion,
  LAG(Champion) OVER
    (PARTITION BY Event
     ORDER BY Event ASC, Year ASC) AS Last_Champion
FROM Discus_Gold
ORDER BY Event ASC, Year ASC;
```

OUTPUT

|Year |Event |Champion |Last_Champion |
|---|---|---|---|
| 2004 | Discus Throw | LTU| null          |
| 2008 | Discus Throw | EST| null          |
| 2012 | Discus Throw | GER| EST           |
| 2004 | Triple Jump  | SWE| null          |
| 2008 | Triple Jump  | POR| SWE           |
| 2012 | Triple Jump  | USA| POR           |


### 연도-국가에 따라 번호 붙이기
```sql
WITH Country_Gold AS (
  SELECT
    DISTINCT Year, Country, Event
  FROM Summer_Medals
  WHERE
    Year IN (2008, 2012)
    AND Country IN ('CHN', 'JPN')
    AND Gender = 'Women' AND Medal = 'Gold')

SELECT
  Year, Country, Event,
  ROW_NUMBER() OVER (PARTITION BY Year, Country)
FROM Country_Gold;
```

OUTPUT

| Year | Country | Event                | Row_N |
|------|---------|----------------------|-------|
|2008|CHN | + 78KG (Heavyweight) |1|
|2008|CHN |-49KG|2|
|...|... | ...|...|
|2008|JPN |48-55KG |1|
|2008|JPN |48-55KG|2|
|...|... | ...|...|
|2012|CHN | +75KG |1|
|2012|CHN |-49KG |2|
|...|... | ...|...|
|2012|JPN | +75KG |1|
|2012|JPN |-49KG |2|
|...|...| ...|...|


### 경기별 득점 수 및 해당 시즌 평균 득점 수와 비교
```sql
SELECT
    date,
    (home_goal + away_goal) AS goals,
    AVG(home_goal + away_goal) OVER(PARTITION BY season) AS season_avg
FROM match;
```

OUTPUT

| date       | goals | season_avg  |
|------------|-------|-------------|
| 2011-12-17 | 3| 2.71646     |
| 2012-05-01 | 2| 2.71646     |
| 2012-11-27 | 4| 2.77270     |
| 2013-04-20 | 1| 2.77270     |
| 2013-11-09 | 5| 2.76682     |

### 경기별 득점 수 및 해당 국가 리그-시즌 평균 득점 수와 비교

```sql
SELECT
  c.name,
  m.season,
  (home_goal + away_goal) AS goals,
  AVG(home_goal + away_goal)
      OVER(PARTITION BY m.season, c.name) AS season_ctry_avg
FROM country AS c
LEFT JOIN match AS m
ON c.id = m.country_id
```

OUTPUT

| name        | season    | goals     | season_ctry_avg |
|-------------|-----------|-----------|-----------------|
| Belgium     | 2011/2012 | 1| 2.88            |
| Netherlands | 2014/2015 | 1| 3.08            |
| Belgium     | 2011/2012 | 1| 2.88            |
| Spain       | 2014/2015 | 2| 2.66            |

## Sliding windows
---
현재 행 (Current row)에 상대적인 calculation을 수행한다.
- running totals, sums, averages 등을 계산하는데 활용
- 1개 이상의 컬럼에 대한 partition 수행 가능

```sql
ROWS BETWEEN <start> AND <finish>
-- Options:
    -- PRECEDING
    -- FOLLOWING
    -- UNBOUNDED PRECEDING
    -- UNBOUNDED FOLLOWING
    -- CURRENT ROW
```

### MC 홈 경기에서 득점, 상대팀 득점, 득점 누계
```sql
-- Manchester City Home Games
SELECT
  date,
  home_goal,
  away_goal,
  SUM(home_goal)
     OVER(ORDER BY date ROWS BETWEEN
          UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total
FROM match
WHERE hometeam_id = 8456 AND season = '2011/2012';
```

OUTPUT

| date       | home_goal | away_goal | running_total |
|------------|-----------|-----------|---------------|
| 2011-08-15 | 4|0 |4| 
| 2011-09-10 | 3|0 |7|
| 2011-09-24 | 2|0 |9|
| 2011-10-15 | 4|1 |13 |

### MC 홈 경기에서 득점, 상대팀 득점, 직전 홈 경기 득점 합산
```sql
-- Manchester City Home Games
SELECT date,
       home_goal,
       away_goal,
       SUM(home_goal)
          OVER(ORDER BY date
          ROWS BETWEEN 1 PRECEDING
          AND CURRENT ROW) AS last2
FROM match
WHERE hometeam_id = 8456
      AND season = '2011/2012';
```
  
OUTPUT

|date|home_goal|away_goal|last2|
|---|---|---|---|
|2011-08-15|4|0|4|
|2011-09-10|3|0|7|
|2011-09-24|2|0|5|
|2011-10-15|4|1|6|

## LAG (Function)
---
`LAG(column, n) OVER (...)`
- 현재 행으로부터 `n`개의 행 이전에 있는 `column`의 값을 반환
- `LAG(column, 1) OVER (...)`은 이전 행에 있는 `column`의 값

### Reigning champion
올해와 작년 대회 모두 우승한 챔피언
- 서로 다른 두 개의 컬럼에 작년 챔피언과 올해 챔피언이 현재 행에 같이 있음
- `올해 우승자 (A) / 작년 우승자 (A)`

```sql
WITH Discus_Gold AS (
  SELECT
    Year, Country AS Champion
  FROM Summer_Medals
  WHERE
    Year IN (1996, 2000, 2004, 2008, 2012)
    AND Gender = 'Men' AND Medal = 'Gold'
    AND Event = 'Discus Throw')
SELECT
  Year, Champion,
  LAG(Champion, 1) OVER
    (ORDER BY Year ASC) AS Last_Champion
FROM Discus_Gold
ORDER BY Year ASC;
```

OUTPUT

| Year | Champion | Last_Champion |
|------|----------|---------------|
|1996|GER | null          |
|2000|LTU | GER           |
|2004|LTU| LTU           |
|2008|EST| LTU           |
|2012|GER| EST           |